<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="footer.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

</head>
<body>
    <div class="translate-parent">
        <h1>Object Oriented Programming Structure</h1>
        <p>As we know java is an object oriented programming language. <br>
            A java program can create one or more than one objects in memory during execution. <br>
            Program can keep data into these objects. <br>
            Methods called by program can get data from these objects and change data of these obejcts also. <br>
            Object can hold multiple values/data. <br> 
            Object can hold different types of values. <br>
            Object can be shared. <br>
            Other programs and methods can use/access object created by a program.</p>
            <strong>OOP (Object-Oriented Programming) is based on four key principles, often referred to as the four(4)..</strong>
            <h3>Pillars of OOPSüöÄ</h3>
            <hr style="border: 1px solid black; width: 22%; margin-top: 5px; margin-left: 0;">
<h4 style="background-color: rgb(247, 3, 3); display: inline-block; color: white; border-radius: 10px;" >
 1Ô∏è‚É£Encapsulation <a style="color: black;">(Data Hiding) </a>  <br> 
 2Ô∏è‚É£ Inheritance<a style="color: black;">(Code Reusability)</a>   <br>
3Ô∏è‚É£Polymorphism <a style="color: black;">(One Name, Many Forms) </a><br>
4Ô∏è‚É£Abstraction <a style="color: black;"> (Hiding Implementation Details)</a> </h4>
<p><strong>The 4 pillars of OOP (Encapsulation, Inheritance, Polymorphism, and Abstraction) make Java:</strong></p>
<h4 style="background-color: #5b636b; display: inline-block; color: white; border-radius: 10px; ">‚úÖ Efficient.. <br>‚úÖ Scalable.. <br>‚úÖ Secure.. <br> ‚úÖ Reusable..</h4>
<center><div class="image-container">
            <img src="image/oops.png" alt="oops img">
           </div></center>
            <h3>What is objectüöÄ</h3>
            <hr style="border: 1px solid black; width: 18%; margin-top: 5px; margin-left: 0;">
            <p>Every real world entity is an object. <br>
                Every object has states. <br>
                Take an example of smartphone. <br>
                8GB RAM is state. <br>
                16GBB ROM is state. <br>
                5000Mh battery is state. <br>
                Black color is state. <br>
                Etc....</p>
                <p>Our program will create a <span class="highlight">container to keep states of real world entity in memory</span>.since real world entity is an object that's why this container is called an object.
                    Object is termed as a <span class="highlight">instance of a class</span>, and it has its own state,behaviour and attribute. <br>
                    Every object has following two characterisitics.....</p>
                   <strong>
                    <ul class="decimal-list">
                        <li>Attributesüåû</li>
                        <li>Behavioursüåû</li>
                    </ul>
                   </strong>
<h3>Creating object by program</h3>
<hr style="border: 1px solid black; width: 32%; margin-top: 5px; margin-left: 0;">
<p>As we know our program will create one or more than one objects to keep states of real world entity in memory. <br>
    <strong>"üìåProgram will create these objects from classüìå"</strong></p>
    <h3>What is classüòä</h3>
    <hr style="border: 1px solid black; width: 20%; margin-top: 5px; margin-left: 0;">
    <p>It is blueprint or template from which objects are created. <br>
        Inside class, properties(attributes and behaviours) of the objects are defined. <br>
        Container that will hold states of the real world entity must have following behaviours.. <br>
<h4 style="background-color: rgb(6, 31, 255); display: inline-block; color: white;">Behaviour to hold data</h4>
        <strong><p>Define variables and constructors inside class for this.</p></strong>
        <h4 style="background-color: rgb(6, 31, 255); display: inline-block; color: white;">Behaviour to change data</h4>
       <strong><p> Define methods inside class.These methods are known as setter.</p></strong>
        <h4 style="background-color: rgb(6, 31, 255); display: inline-block; color: white;">Behaviour to get data</h4> <br>
        <strong>Define methods inside class.These methods are known as getter.</strong>  <br>
        A class is a simply a reparsentation of a type of object It is the blue/plan/template that describe the details..</p>
        <h4>Example‚úîÔ∏è</h4>
<pre>
    public class Product
    {
      //declaring variabe to hold state of product
      int pid;
      String name;
      String brand;
      int price;
      //defining constructor 
      public Product(int a1,String a2,String a3,int a4) 
      {
        this.pid=a1;
        this.name=a2;
        this.brand=a3;
        this.price=a4;
      }
       
    }
 </pre>
 <h1>Instance variable</h1>
 <p>A variable which is declared inside class <span class="highlight">without using static keyword </span> is known as instance variable</p>
 <p><strong>
    public class AA  <br>
{  <br>
  int x;//instance variable  <br>
  static int y;//class variable  <br>
}
 </strong></p>
 <p>Command to create instance variable will be executed each time object from that class will be created.<br> It means this variable can have multiple copies in memory. <br>
    <span class="highlight">Remember every object is instance of a class.</span></p>
    <p>An instance variable in Java is a non-static variable that belongs to an instance (object) of a class. Each object of the class has its own copy of the instance variable.</p>
    <p>‚úÖ They are created when an object is created and destroyed when the object is destroyed.</p>
    <p>‚úÖ Instance variables can have different values for different objects.</p>
    ‚úÖ By default, they are initialized with default values (e.g., 0 for int, null for objects, false for boolean, etc.).
    <p>‚úÖ Instance variables are stored in Heap memory.</p>
    <p>‚úÖ Use instance variables when each object needs separate data.</p>
    <h3>Command to create object‚ö°</h3>
    <hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
    <p> <strong>new Classname(); <br>
        new Classname(parameters/arguments);
        </p></strong>
        <p>When above command will run, following tasks will be performed internally..</p>
<strong>
 <ul class="decimal-list">
    <li>Instance variable will be created <span class="highlight">Memory to the object is allocated</span></li>
    <li>Unique reference of these variables will be generated <span class="highlight">Reference of the object is generated</span></li>
    <li>These variable will be initialized <span class="highlight">Value will be Object is initialized</span></li>
    <li>Reference of these variables will be returned <span class="highlight">/Reference of the object is returned</span>
    </li>
        </ul>      
</strong>
<pre>
<h3>Example..</h3>
public class Product 
{
	//Declaring instance variable
	int pid;
	String name;
	String brand;
	int price;
	
	//Defining constructor
	public Product(int a1,String a2,String a3,int a4)
	{
		this.pid=a1;
		this.name=a2;
		this.brand=a3;
		this.price=a4;
	}
	//Defining method
	public void showDetails()
	{
		System.out.println("Product id is:"+this.pid);
		System.out.println("Product name is:"+this.name);
		System.out.println("Product brand is:"+this.brand);
		System.out.println("Product price is:"+this.price);
		System.out.println("--------------------------------");
	}
}
public class App 
{
	public static void main(String[] args) 
	{
		//Declaring reference variable
		Product p1,p2,p3;
		//Command to create object from Product
		p1=new Product(101,"Mouse","Logitech",1500);
		p2=new Product(102,"Printer","Dell",6500);
		p3=new Product(103,"Keyboard","Logitech",2500);
		
		//Command to call showDetails() method of class Product
		p3.showDetails();
	}
}
OUTPUT
103,"Keyboard","Logitech",2500
       </pre>
       <strong>üìåDefining <span class="highlight">getter</span>(To get vlaue from the object) and <span class="highlight">setter</span>(To change value of the object) inside class..üìå</strong>
       <pre>
public class Point
{
  //Declaring instance variables
  int x;
  int y;
  //Defining constructor
  public Point(int a1,int a2)
  {
	this.x=a1;
	this.y=a2;
  }
  //Defining getters
  public int getX()
  {
	return this.x;
  }  
  public int getY()
  {
	return this.y;
  }  
  //Defining setters 
  public void setX(int a)
  {
	this.x=a;
  }
  public void setY(int a)
  {
	this.y=a;
  }
}
       </pre>
<h4>üìåInside a Product class using a getter and setter Methodüìå</h4>
<pre>
public class Product 
{
	//Declaring instance variable
	int pid;
	String name;
	String brand;
	int price;
	
	//Defining constructor
	public Product(int a1,String a2,String a3,int a4)
	{
		this.pid=a1;
		this.name=a2;
		this.brand=a3;
		this.price=a4;
	}
	//Defining method
	public void showDetails()
	{
		System.out.println("Product id is:"+this.pid);
		System.out.println("Product name is:"+this.name);
		System.out.println("Product brand is:"+this.brand);
		System.out.println("Product price is:"+this.price);
		System.out.println("--------------------------------");
	}
	//Defining getters
	public int getPid()
	{
		return this.pid;
	}
	public String getName()
	{
		return this.name;
	}
	public String getBrand()
	{
		return this.brand;
	}
	public int getPrice()
	{
		return this.price;
	}
	//Defining setters
	public void setPid(int arg)
	{
		this.pid=arg;
	}
	public void setName(String arg)
	{
		this.name=arg;
	}
	public void setBrand(String arg)
	{
		this.brand=arg;
	}
	public void setPrice(int arg)
	{
		this.price=arg;
	}
}
public class App 
{
	public static void main(String[] args) 
	{
		Product p1,p2,p3;
		p1=new Product(101,"Mouse","Logitech",1500);
		System.out.println("Before changing price");
		p1.showDetails();
		p1.setPrice(2000);
		System.out.println("After changing price");
		p1.showDetails();
	}
output 
Before changing price
Product id is:101
Product name is:Mouse
Product brand is:Logitech
Product price is:1500
--------------------------------
After changing price
Product id is:101
Product name is:Mouse
Product brand is:Logitech
Product price is:2000
--------------------------------
}
</pre>
<h3>üìågetprice and showüìå</h3>
<pre>
class App2 
    {
        public static void main(String[] args) 
        {
            Product p1,p2,p3;
            p1=new Product(101,"Mouse","Logitech",1500);
            
            int x=p1.getPrice();
            
            System.out.println("Price of the product is:"+x);
        }
output 
Price of the product is:1500
}
</pre>
<h3>üìågetprice and setpriceüìå</h3>
<pre>
class App3 
    {
        public static void main(String[] args) 
        {
            Product p1,p2,p3;
            p1=new Product(101,"Mouse","Logitech",1500);
            //Write code to increase price of the product by 100;
            int x=p1.getPrice();
            x=x+100;
            p1.setPrice(x);
            System.out.println("Price of the product is:"+x);
        }
output 
Price of the product is:1600
}
</pre>
<h1>Static Variable</h1>
<p>A static variable in Java is a <span class="highlight">class-level variable</span> that is shared among all instances of the class. It is declared using the static keyword.</p>
<h3>Characteristics of Static VariablesüöÄ</h3>
<hr style="border: 1px solid black; width: 40%; margin-top: 5px; margin-left: 0;">
<p>‚úÖ Belongs to the class, not to a specific object. <br>
   ‚úÖ Shared among all objects of the class (only one copy exists in memory).  <br>
   ‚úÖ Stored in the Method Area (not in the Heap).  <br>
   ‚úÖ Can be accessed using the class name (no need for an object). <br>
   ‚úÖ Initialized only once when the class is loaded into memory.
    
    </p>
    <h4>Class-Level Variableüîé</h4>
    <hr style="border: 1px solid black; width: 22%; margin-top: 5px; margin-left: 0;">
    <p>It is associated with the class rather than individual objects.</p>
    <h4>Single Copy in Memoryüîé</h4>
    <hr style="border: 1px solid black; width: 22%; margin-top: 5px; margin-left: 0;">
    <p>Only one copy of a static variable exists, shared by all instances of the class.</p>
    <h4>Stored in the Method Areaüîé</h4>
    <hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
    <p>Unlike instance variables (which are stored in the Heap), static variables are stored in the Method Area of memory.</p>
    <h4>Accessed Using Class Nameüîé</h4>
    <hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
    <p>A static variable can be accessed directly using the class name, without creating an object.</p>
    <h4>Lifetimeüîé</h4>
    <hr style="border: 1px solid black; width: 8%; margin-top: 5px; margin-left: 0;">
    <p>It is initialized when the class is loaded into memory and destroyed when the class is unloaded.</p>
    <h4>How Static Variables Work? (Memory Representation)üôÇ</h4>
    <hr style="border: 1px solid black; width: 50%; margin-top: 5px; margin-left: 0;">
    <p>When a class is loaded into memory, only one copy of the static variable is created in the Method Area.
        Each instance (object) of the class refers to this single copy instead of creating a new one</p>
<h4 style="background-color: rgb(110, 114, 92); display: inline-block;color:rgb(253, 239, 239); border-radius: 25%;">NOTE</h4>
<p>A static variable always has a single copy because it is stored in the class area.That's why its value gets updated whenever it is changed, and it stores only the last assigned value.</p>
<h4>Example‚úîÔ∏è</h4>
<pre>
    class Example {
        static int y;  // Static variable
    
        public Example(int b) {
            Example.y = b;  // Updating static variable
        }
    
        public void show() {
            System.out.println("y = " + y);
        }
    
        public static void main(String[] args) {
            Example obj1 = new Example(10);
            Example obj2 = new Example(20);
            Example obj3 = new Example(30); // Last value assigned
    
            obj1.show();
            obj2.show();
            obj3.show();
    }
}
</pre>
<p style="background-color: rgb(86, 105, 0);">Static variable sirf ek baar memory me allocate hota hai (class area me), aur sabhi objects usi ek copy ko share karte hain.Jab bhi koi object static variable ki value change karega, wo sabhi objects ke liye update ho jayegi, kyunki static variable ki ek hi copy hoti hai.Agar multiple objects static variable ko modify karein, to last assigned value hi store hoti hai.</p>
<pre>
    class AA {
        int x;       // Instance variable
        static int y; // Static variable
    
        // Constructor (Fixed Syntax)
        public AA(int a, int b) {  
            this.x = a;   // Assign instance variable
            AA.y = b;     // Assign static variable
        }
    
        public void show() {
            System.out.println("x = " + x); // Instance variable (different for each object)
            System.out.println("y = " + y); // Static variable (shared by all objects)
        }
    
        public static void main(String[] args) {
            AA obj1 = new AA(100, 100);
            AA obj2 = new AA(50, 50);
            AA obj3 = new AA(12, 12);
    
            obj1.show();
            obj2.show();
            obj3.show();
        }
    }
output
x = 100
y = 12
x = 50
y = 12
x = 12
y = 12
</pre>
<p><strong>Static variables are shared</strong> ‚Üí Last assigned value affects all objects.</p>
<pre>
 class Employee {
    int empId;  // Instance Variable
    String empName;
    static String companyName = "TechCorp"; // Static Variable
    // Constructor
    Employee(int id, String name) {
                    this.empId = id;
                    this.empName = name;
 }
    void display() {
    System.out.println("ID: " + empId + ", Name: " + empName + ", Company: " + companyName);
    }
    }
    public class Main {
     public static void main(String[] args) {
     Employee e1 = new Employee(101, "Alice");
     Employee e2 = new Employee(102, "Bob");
     e1.display();
     e2.display();
     // Changing the static variable value
     Employee.companyName = "NewTech";
     e1.display();
     e2.display();
     }
     }
output 
ID: 101, Name: Alice, Company: TechCorp  
ID: 102, Name: Bob, Company: TechCorp  

ID: 101, Name: Alice, Company: NewTech  
ID: 102, Name: Bob, Company: NewTech  

            
        </pre>
        <h4>When to Use Static Variablesüìå</h4>
        <hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
        <p>‚úÖ When a value needs to be shared among all objects (e.g., a company name, tax rate, interest rate). <br>
            ‚úÖ To save memory, as only one copy exists in memory.  <br>
            ‚úÖ For constants or configuration values that should be consistent across instances.</p>
<pre>
<strong> Counting the Number of Objects Created</strong>
class Counter {
        static int count = 0; // Static variable
    
        Counter() {
            count++; // Increment the count when an object is created
        }
    
        void displayCount() {
            System.out.println("Total Objects: " + count);
        }
    }
    
public class Main {
        public static void main(String[] args) {
            Counter c1 = new Counter();
            Counter c2 = new Counter();
            Counter c3 = new Counter();
    
            c3.displayCount(); // Output: Total Objects: 3
        }
    }
count is static, so it is shared by all objects.
Every time a new object is created, count increases.
This helps us keep track of how many objects have been created.
    
</pre>
<p>A static variable belongs to the class, not objects. <br>
    Only one copy of a static variable exists in memory (Method Area).  <br>
    It can be accessed using the class name (best practice).  <br>
    Used for constants, shared resources, and memory optimization.</p>
    <center><h4>üìåStatic Variable vs. Instance Variableüìå</h4></center>
    <center><hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;"></center>
   <br>
   <center>
    <table style="border: 5px solid black; background-color: rgb(192, 250, 85); border-collapse: collapse;">
        <tr>
            <th style="border: 5px solid black; padding: 5px;">Feature</th>
            <th style="border: 5px solid black; padding: 5px;">Instance Variable</th>
            <th style="border: 5px solid black; padding: 5px;">Static Variable</th>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Belongs To</td>
            <td style="border: 5px solid black; padding: 5px;">Object</td>
            <td style="border: 5px solid black; padding: 5px;">Class</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Memory</td>
            <td style="border: 5px solid black; padding: 5px;">Stored in Heap memory</td>
            <td style="border: 5px solid black; padding: 5px;">Stored in Method Area</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Access</td>
            <td style="border: 5px solid black; padding: 5px;">Needs object to access</td>
            <td style="border: 5px solid black; padding: 5px;">Can be accessed using class name</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Separate Copy for Objects?</td>
            <td style="border: 5px solid black; padding: 5px;">Yes</td>
            <td style="border: 5px solid black; padding: 5px;">No (Shared across all objects)</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Lifetime</td>
            <td style="border: 5px solid black; padding: 5px;">Created when an object is created</td>
            <td style="border: 5px solid black; padding: 5px;">Created when the class is loaded</td>
        </tr>
    </table>
</center>
<h3>Encapsulation</h3>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p>Wraping up <b>attribute</b> and <b> behaviour </b> of the object into a single unit is called encapsulation.  <br>
This is achived by define a class <b>getter()</b> and <b>setter()</b> method. <br>
Advantage of encapsulation is <b>data hiding</b> .for this instance variable must be <b>private</b> .</p>
<h4>Encapsulation is achieved using</h4>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p> <b>Private variables</b> (restrict direct access). <br>
Public <b>getter</b> and <b>setter</b> methods (provide controlled access)</p>
<h4>Why Use Encapsulation</h4>
<hr style="border: 1px solid black; width: 30%; margin-top: 5px; margin-left: 0;">
<p>‚úÖ <b>Data Hiding:</b> Prevents unauthorized access to data.  <br>
    ‚úÖ <b>Better Code Control:</b> Only specific methods can modify data.  <br>
    ‚úÖ <b>Flexibility and Maintainability:</b> Changes can be made without affecting other parts of the program.  <br>
    ‚úÖ <b> Improves Security:</b> Sensitive data remains protected.</p>
    <h4>Example: Without Encapsulation (Data is not protected)</h4>
<pre>
    class Person {
        String name;  // Public variable (BAD practice)
        int age;
    }
    
    public class Main {
        public static void main(String[] args) {
            Person p = new Person();
            p.name = "John"; // Direct access (BAD)
            p.age = 25;
    
            System.out.println("Name: " + p.name);
            System.out.println("Age: " + p.age);
    
            // Directly modifying data (BAD)
            p.age = -5; // Invalid age but no restriction!
            System.out.println("Updated Age: " + p.age);
        }
    }    
</pre>
<p> <b>No Data Validation:</b> Anyone can set an invalid age (-5 years old).  <br>
    <b>No Security:</b> Any part of the code can change data unexpectedly. <br>
    <b>No Control:</b> We cannot prevent unauthorized changes.</p>
<h4>Encapsulation Applied (Using Private Variables & Getters/Setters)</h4>
<pre>
    class Person {
        // Private variables (Cannot be accessed directly)
        private String name;
        private int age;
    
        // Public setter method (to set data)
        public void setName(String name) {
            this.name = name;
        }
    
        // Public getter method (to retrieve data)
        public String getName() {
            return name;
        }
    
        // Setter method with validation
        public void setAge(int age) {
            if (age > 0) { // Age cannot be negative
                this.age = age;
            } else {
                System.out.println("Invalid age. Setting age to 0.");
                this.age = 0; // Default value
            }
        }
    
        // Getter method
        public int getAge() {
            return age;
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            Person p = new Person();
    
            // Setting values using setter methods
            p.setName("John");
            p.setAge(25);
    
            // Accessing values using getter methods
            System.out.println("Name: " + p.getName());
            System.out.println("Age: " + p.getAge());
    
            // Attempt to set an invalid age
            p.setAge(-5);
            System.out.println("Updated Age: " + p.getAge()); // Output: 0 (validation applied)
        }
    }    
</pre>
<h4>Encapsulation in Real-World Scenarios</h4>
<pre>
    class BankAccount {
        private double balance;
    
        public void deposit(double amount) {
            if (amount > 0) {
                balance += amount;
                System.out.println("Deposited: $" + amount);
            } else {
                System.out.println("Invalid deposit amount.");
            }
        }
    
        public void withdraw(double amount) {
            if (amount > 0 && amount <= balance) {
                balance -= amount;
                System.out.println("Withdrawn: $" + amount);
            } else {
                System.out.println("Insufficient balance or invalid amount.");
            }
        }
    
        public double getBalance() {
            return balance;
        }
    }
    
    public class Main {
        public static void main(String[] args) {
            BankAccount account = new BankAccount();
            account.deposit(500);
            account.withdraw(200);
            System.out.println("Current Balance: $" + account.getBalance());
        }
    }
output 
Deposited: $500.0
Withdrawn: $200.0
Current Balance: $300.0    
</pre>
<p> <b>Private Balance:</b> Users cannot directly change balance. <br>
   <b> Controlled Transactions:</b> Only deposit and withdrawal methods are allowed. <br>
   <b>Patient Records:</b> Keep sensitive medical information private. <br>
   <b>Controlled Updates:</b> Only authorized doctors can modify records. </p>
   <center>

    <table style="border: 5px solid black; background-color: rgb(192, 250, 85); border-collapse: collapse;">
    
        <tr>
            <th style="border: 5px solid black; padding: 5px;">Feature</th>
            <th style="border: 5px solid black; padding: 5px;">Without Encapsulation</th>
            <th style="border: 5px solid black; padding: 5px;">With Encapsulation</th>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Access Control</td>
            <td style="border: 5px solid black; padding: 5px;">Data is public and modifiable</td>
            <td style="border: 5px solid black; padding: 5px;">Data is private, controlled by methods</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Security</td>
            <td style="border: 5px solid black; padding: 5px;">Low (anyone can modify data)</td>
            <td style="border: 5px solid black; padding: 5px;">High (controlled access)</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Data Validation</td>
            <td style="border: 5px solid black; padding: 5px;">No validation (invalid values possible)</td>
            <td style="border: 5px solid black; padding: 5px;">Allows validation (prevents errors)</td>
        </tr>
        <tr>
            <td style="border: 5px solid black; padding: 5px;">Maintainability</td>
            <td style="border: 5px solid black; padding: 5px;">Hard to manage</td>
            <td style="border: 5px solid black; padding: 5px;">Easier to maintain</td>
        </tr>
    </table>
   </center>
<p>‚úÖ Benefits: Data security, controlled access</p>
<h3>Instantiation</h3>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p> Creating object from the class is called instantitation. <br>
    Remeber every object instance of a class.</p>
<h3>Inheritance</h3>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;"> 
<p>It is one of the OOPS concept.  <br>
    Acquiring properties(methods and variables) by a new class from an existing class is called inheritance. <br>
    Inheritance is a concept where one class shares  the structure and behaviour defined in another class.  <br>
    Advantage is inheritance is code reusability.</p>
<h4>Example..Task</h4>
<p>Define/create following four classes  <br>
    Addition  <br>
    Multiplication   <br>
    Subtraction   <br>
    Division   <br>
    In each class define following properties
    1.Define three int type instance variables in class <br>
    2.Define method in each class to accept two integer value from user and assign then into first two instance variables  <br>
    3.Define one method in each class to perform required arithmetic operation value of first two instance variables and assign result into third instance variable.Remember this method will not be common <br>
    4.Define method in each class to print/display value of third instance variable</p>
<h4>Without using Inheritance properties</h4>
<pre>
    import java.util.Scanner;
    class Addition 
    {
        private int num1;
        private int num2;
        private int res;
        public void acceptNumbers()
        {
            Scanner sc=new Scanner(System.in);
            System.out.print("Enter first number:");
            this.num1=sc.nextInt();
            System.out.print("Enter second number:");
            this.num2=sc.nextInt();
        }
        public void add()
        {
            this.res=this.num1+this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
    class Subtraction
    {
        private int num1;
        private int num2;
        private int res;
        
        public void acceptNumbers()
        {
            Scanner sc=new Scanner(System.in);
            System.out.print("Enter first nujmber:");
            this.num1=sc.nextInt();
            System.out.print("Enter second nujmber:");
            this.num2=sc.nextInt();
        }
        public void subtract()
        {
            this.res=this.num1-this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
    class Multiplication 
    {
        private int num1;
        private int num2;
        private int res;
        
        public void acceptNumbers()
        {
            Scanner sc=new Scanner(System.in);
            System.out.print("Enter first nujmber:");
            this.num1=sc.nextInt();
            System.out.print("Enter second nujmber:");
            this.num2=sc.nextInt();
        }
        public void multiply()
        {
            this.res=this.num1*this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
     class Division 
    {
        private int num1;
        private int num2;
        private int res;
        
        public void acceptNumbers()
        {
            Scanner sc=new Scanner(System.in);
            System.out.print("Enter first nujmber:");
            this.num1=sc.nextInt();
            System.out.print("Enter second nujmber:");
            this.num2=sc.nextInt();
        }
        public void divide()
        {
            this.res=this.num1/this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
     class App 
    {
        public static void main(String[] args) 
        {
            Addition o1=new Addition();
            o1.acceptNumbers();
            o1.add();
            o1.showResult();
            //Substraction 01=new substraction();
            //01.acceptNumber();
            //Multiplication 01=new multiplication();
            //01.acceptNumber();
            //Divition 01=new Divition();
            //01.acceptNumber();
        } 
}   
</pre>
<h4>Using Inheritance properties.</h4>
<pre>
    import java.util.Scanner;
    class Arithmetic
    {
        protected int num1;
        protected int num2;
        protected int res;
        public void acceptNumbers()
        {
            Scanner sc=new Scanner(System.in);
            System.out.print("Enter first number:");
            this.num1=sc.nextInt();
            System.out.print("Enter second number:");
            this.num2=sc.nextInt();
        }
    }
    class Addition extends Arithmetic
    {
        public void add()
        {
            this.res=this.num1+this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
    class Subtraction extends Arithmetic
    {
        public void subtract()
        {
            this.res=this.num1-this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
    class Multiplication extends Arithmetic
    {
        public void multiply()
        {
            this.res=this.num1*this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
    class Division extends Arithmetic
    {
        public void divide()
        {
            this.res=this.num1/this.num2;
        }
        public void showResult()
        {
            System.out.println("Result="+this.res);
        }
    }
    class App 
    {
        public static void main(String[] args) 
        {
            Addition o1=new Addition();
            o1.acceptNumbers();
            o1.add();
            o1.showResult();
            Subtraction o2=new Subtraction();
            o2.acceptNumbers();
            o2.subtract();
            o2.showResult();
            Multiplication o3=new Multiplication();
            o3.acceptNumbers();
            o3.multiply();
            o3.showResult();
            Division o4=new Division();
            o4.acceptNumbers();
            o4.divide();
            o4.showResult();
        }
    }                                                               
 </pre>
 <h3>When to use inheritance</h3>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p><b>1.When you want to create extension of an existing class.  <br>
    2.When you want to define multiple classes in hierarchical manner. </b> <br> 
     <b>Code Reusability</b> - Avoid rewriting the same code.  <br>
     <b>Extensibility</b> - Easily extend functionalities of an existing class. <br>
     <b> Organized Code</b> - Create a logical hierarchy.  <br>
     <b>Polymorphism Support</b> - Allows method overriding. 
    </p>
<code style="color: white;">
    public class AA   //parent class   <br>
    {    <br>
      //properties   <br> 
    }  <br>
    public class BB extends AA //child class  <br>
    {   <br>
      //properties   <br>
    }  <br>
    {   <br>
      //properties  <br>
    }  <br>
</code>
<p>Here class BB is inheriting/acquiring properties from the class AA.  <br>
    Class BB will be sub/child/derived class of class AA. <br> 
    Class AA will be super/parent/base class of class BB.</p>
<h1>Types of Inheritace</h1>
<br>
<h4 style="background-color: rgb(60, 63, 68); display: inline-block; color: white; border-radius: 10px; padding: 10px;">
    1Ô∏è‚É£ Single Inheritance <a style="color: rgb(173, 216, 230);"> (Simple Inheritance (SI))</a>  <br> 
    2Ô∏è‚É£ Multiple Inheritance <a style="color: rgb(173, 216, 230);"> (Multi-Base Inheritance (MI))</a>   <br>
    3Ô∏è‚É£ Multilevel Inheritance <a style="color: rgb(173, 216, 230);"> (Chain Inheritance (MLI))</a> <br>
    4Ô∏è‚É£ Hierarchical Inheritance <a style="color: rgb(173, 216, 230);"> (Tree Inheritance (HI))</a>  <br>
    5Ô∏è‚É£ Hybrid Inheritance <a style="color: rgb(173, 216, 230);"> (Mixed Inheritance (HBI))</a>
</h4>
<br>
<br>
<center>
    <div class="image-container" style="background-color:rgb(180, 252, 122);border-radius: 10px;">
        <img src="image/inheritance.png" alt="Inheritace Architecture">
        <img src="image/inheritance2.png" alt="Inheritace Architecture">
    </div>
</center>
<br>
<h3>Single Inheritance (Simple Inheritance (SI))</h3>
<hr style="border: 1px solid black; width: 50%; margin-top: 5px; margin-left: 0;">
<p>There are only two class <br>
    First one is parent class and that class has no parent and only one child class. <br>
    Second one is child class and that class has only one parent and no child class. <br>
    Inheriting properties from a single class is single inheritance. <br>
    The child class gets access to the methods and variables of the parent class.  <br>
    It can use them as they are or modify them as needed. 
</p>
<p>
    <b>
        class Parent  <br>
        {  <br>
            //properties  <br>
        }  <br>
        class Child extends Parent  <br>
        {  <br>
            //properties  <br>
        }  <br>
    
    </b>
</p>
<h4>Example.......</h4>
<pre>
    class Parent
    {
        public void show()
        {
            System.out.println("Parent class method");
        }
    }
    class Child extends Parent
    {
        public void display()
        {
            System.out.println("Child class method");
        }
    }
    class App
    {
        public static void main(String[] args) 
        {
            Child c=new Child();
            c.show();
            c.display();
        }
    }`
output
Parent class method
Child class method
--------------------------------------------------------------------------------------
Explanation:
The parent class has a method show().
The Child class inherits the parent class using extends.
The Child class has its own method display().
The Child object can use both show() (from parent) and display() (from itself).
</pre>
<br>
<h4>Real-Life Example (Understanding with a Simple Scenario)</h4>
<p>Vehicle (Parent) has common properties like wheels and an engine. <br>
    Car (Child) inherits these properties but adds more features like AC and music system.</p>
<pre>
    // Parent class
    class Vehicle {
        void start() {
            System.out.println("Vehicle is starting...");
        }
    }
    
    // Child class
    class Car extends Vehicle {
        void playMusic() {
            System.out.println("Playing music in the car...");
        }
    }
    
    // Main method
    public class Main {
        public static void main(String[] args) {
            Car myCar = new Car();
            myCar.start();      // Inherited from Vehicle
            myCar.playMusic();  // Defined in Car
        }
    }
output
Vehicle is starting...
Playing music in the car...
</pre>
<h3>Multiple inheritance(Multi-Base Inheritance (MI))</h3>
<hr style="border: 1px solid black; width: 30%; margin-top: 5px; margin-left: 0;">
<p>Inheriting properties from multiple classes is multiple inheritance <br>
    When child class has multiple parent class then this inheritance is called multiple inheritance. <br>
    In java this inheritance is not allowed inside classes but allowed inside interfaces.</p>
<p>
 <b>
    class Parent1  <br>
    {  <br>
        //properties  <br>
    }  <br>
    class Parent2  <br>
    {  <br>
        //properties  <br>
    }  <br>
    class Child extends Parent1,Parent2  <br>
    {  <br>
        //properties  <br>
    }  <br>
</b>
</p>
<p>
    Here class CC is inheriting properties from class AA and BB  <br>
    This will be multiple inheritance  <br>
    In java multiple inheritance is not allowed in classes.  <br>
    C++ and Python allows multiple inheritance in classes.  <br>
    In java multiple inheritance is allowed in interfaces.   
</p>
<h4>üö´ Why Java Doesn't Support Multiple Inheritance with Classes</h4>
<hr style="border: 1px solid black; width: 50%; margin-top: 5px; margin-left: 0;">
<p>
    1.Imagine we have two parent classes with the same method name. If a child class inherits both, Java won't know which method to use.This is called the <b>Diamond Problem </b><br>
       2. In Java, multiple inheritance (through classes) is not directly allowed, so the traditional <b>Diamond Problem</b> does not occur. <br> 3.If method names are not the same, then theoretically there is no ambiguity, but Java still does not allow multiple classes inheritance. <br> 4.Java supports <b>multiple inheritance</b> through interfaces. In interfaces, only method <b>declarations</b> exist, so there is no <b>ambiguity</b>. <br>
   5.But in <b>Java 8</b> features, the <b>diamond problem </b> can occur with <b>default methods</b> because we have two different <b>interfaces</b> with the same method name, and their <b>implementation</b> can be either different or the same. When we <b>implement</b> these interfaces in a class, the <b>diamond problem</b> can happen.To solve this, we need to <b> override</b> that method in the class. After overriding, the method belongs to the <b>class</b>, and we can either change its <b>implementation</b> or keep it the same.
    However, if the interfaces have the same method name but different <b>implementations</b>, and we want to <b>call</b> both methods based on the interface in the class, we need to use the <b>super</b> keyword with the interface name inside the overridden method. Example.. <code>AA.super.show();</code> </p>
<h4>Example of the Diamond Problem (If Java Allowed Multiple Inheritance with Classes)</h4>
<pre>
    class Parent1 {
        void show() {
            System.out.println("Parent1 Show Method");
        }
    }
    
    class Parent2 {
        void show() {
            System.out.println("Parent2 Show Method");
        }
    }
    
    // ‚ùå Java does NOT allow this!
    class Child extends Parent1, Parent2 {
        public static void main(String args[]) {
            Child obj = new Child();
            obj.show(); // Which show() method to call? Parent1 or Parent2? ‚ùå
        }
    }
<p>üëâ Java avoids this confusion by NOT allowing multiple inheritance with classes.</p>    
</pre>
<h4 style="background-color: goldenrod; border-radius: 3px; display: inline-block;">NOTE Deeply Explanation(Hindi)üëá</h4>
<p>Java me multiple inheritance (multiple classes se direct inheritance) allow nahi hai kyunki yeh ambiguity create kar sakti hai. Agar ek child class do parent classes ko inherit karti hai aur dono parent me same method hai, to Java ko yeh decide karne me dikkat hogi ki kaunsi method call ki jaye. Isliye Java Diamond Problem ko avoid karta hai kyunki multiple classes inherit hi nahi hoti. <br>
    Lekin aap yeh bhi keh sakte hai ki agar method name same na ho to ‚Äî tab bhi Java me theoretically ambiguity nahi hoti, lekin Java phir bhi support nahi karta kyunki yeh multiple classes ko inherit hi nahi kar sakta. <br>
    Inheritance ka purpose hi hota hai ek class ke data members aur method implementation ko dusri class ko dena, jo ambiguity create kar sakti hai. <br>
    Java ko simpler rakhne ke liye single inheritance (extends) aur multiple interface (implementation) ka concept rakha gaya hai. <br> 
    Lekin C++ me multiple class inheritance possible hai, isliye C++ me Diamond Problem aata hai kyunki dono classes me method name same ho sakte hai. <br> C++ me Diamond Problem ko solve karne ke liye virtual inheritance ka use kiya jata hai. Virtual inheritance ensure karta hai ki common base class ka sirf ek instance ho, chahe multiple inheritance kyu na ho. <br>
   <b>Example (C++) </b> Agar A class hai, usko extend kiya hai B class aur C class ne, aur ek D class hai jo B aur C ko extend karti hai, to D ke paas A class ki do copies aa jati hai. Isliye virtual keyword ka use kiya jata hai taki D class ke paas sirf single instance aaye, jisse Diamond Problem na ho. <br> 
   Java 8 feature me default method aaya jisme method ka body de sakte hai. To phir agar do alag-alag interface ke same name ka method ho aur uska implementation same ya alag-alag ho, to isme Diamond Problem aa sakta hai.
   Isko solve karne ke liye hame jo class implement kar rahi hai in interfaces ko, us class me in methods ko override karna padega. Tab jaakar problem solve hoga. Override karne ke baad method ka implementation change ya same bhi rakh sakte hai. Override karne par JVM ko yeh samajh aata hai ki jo class implement kiya hai interface, wo us class ka method hai, isliye problem solve ho jata hai.
   Lekin agar dono methods same hai aur in dono methods ko call karna hai, to uske liye override method me interface ka naam super keyword ke sath likhna hoga aur method ka naam batana hoga, tab jaakar call hoga. üíñ Dhanyawad! Happy Coding! üë®‚ÄçüíªüöÄ </p>
<h3>Multilevel Inheritance (Chain Inheritance (MLI))</h3>
<hr style="border: 1px solid black; width: 40%; margin-top: 5px; margin-left: 0;">
<p>
    A child class inherits from a parent class. <br> 
    Another child class inherits from this child class. <br>
    This creates a chain of inheritance (Grandparent ‚Üí Parent ‚Üí Child). <br>
    Grandfather ‚Üí Father ‚Üí Son (Each generation inherits properties from the previous one)   
</p>
<p>
    <b>
        class GrandParent  <br>
        {  <br>
            //properties  <br>
        }  <br>
        class Parent extends GrandParent  <br>
        {  <br>
            //properties  <br>
        }  <br>
        class Child extends Parent  <br>
        {  <br>
            //properties  <br>
        }  <br>
    </b>
</p>
<h4>Real-Time Example of Multilevel Inheritance in Java</h4>
<pre>
    // Grandparent class
    class CEO {
        String companyName = "Tech Solutions";
    
        void displayCompany() {
            System.out.println("Company Name: " + companyName);
        }
    }
    
    // Parent class inheriting CEO
    class Manager extends CEO {
        String department = "Software Development";
    
        void displayDepartment() {
            System.out.println("Department: " + department);
        }
    }
    
    // Child class inheriting Manager
    class Employee extends Manager {
        String employeeName = "John Doe";
    
        void displayEmployee() {
            System.out.println("Employee Name: " + employeeName);
        }
    
        public static void main(String[] args) {
            Employee emp = new Employee();
            emp.displayCompany();      // Inherited from CEO
            emp.displayDepartment();   // Inherited from Manager
            emp.displayEmployee();     // Defined in Employee
        }
    }
output
Company Name: Tech Solutions
Department: Software Development
Employee Name: John Doe       
</pre>
<br>
<pre>
    class Animal {
        void eat() {
            System.out.println("Animals eat food.");
        }
    }
    
    class Mammal extends Animal {
        void warmBlooded() {
            System.out.println("Mammals are warm-blooded.");
        }
    }
    
    class Dog extends Mammal {
        void bark() {
            System.out.println("Dogs bark.");
        }
    
        public static void main(String[] args) {
            Dog myDog = new Dog();
            myDog.eat();        // Inherited from Animal
            myDog.warmBlooded();// Inherited from Mammal
            myDog.bark();       // Defined in Dog
        }
    }
output
Animals eat food.
Mammals are warm-blooded.
Dogs bark.    
</pre>
<h3>Hybrid Inheritance (Mixed Inheritance (HBI))</h3>
<hr style="border: 1px solid black; width: 50%; margin-top: 5px; margin-left: 0;">
<p>
    Hybrid inheritance is a <b>combination of two or more types of inheritance</b>. Since Java <b>does not support multiple inheritance with classes</b> (to prevent ambiguity), hybrid inheritance is achieved using interfaces.
</p>
</div>
</body>
</html>