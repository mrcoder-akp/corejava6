<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="responsive.css">
    <link rel="stylesheet" href="footer.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

</head>
<body>
<div>
<h1>String </h1>  
<p>It is set of characters or array of characters. <br>
It is set of characters(alphabat,digits,symbol) you can also say,it is array of characters.  <br>
It is used to store data in memory. <br>
If java program wants to keep string in memory then char type array must be created by program to keep this string. <br>
If we will write command to create this array then it will be difficult because we do not know the size of string
Code to create this array is predefined <br>
It is set of sequential characters(In the form of array). <br>
In java string value is written within "" <br>
String is immutable in java. <br>
char type arrya is required to keep string in memory. <br>
String is a class in java. <br>
Following three classes has code to create this array <br>
<h4 style="background-color: rgb(90, 13, 13); display: inline-block; color: white; border-radius: 5%;">
1➡️String class  <br>
2➡️StringBuffer class <br>
3➡️StringBuilder class   
</h4> <br>
String class is used to create string object. <br>
Our program will create object from one of the above class and pass string to the contructor of above class. <br>
These classes are in java.lang.package </p> 
<p>String str1=new String("Avinash"); <br>
StringBuffer str2=new StringBuffer("Akash"); <br>
StringBuilder str3=new StringBuilder("Devansh");<br>
<strong><span class="highlight">"Avinash"</span>=This is a string literls.</strong></p>
<h4>NOTE</h4>
<hr style="border: 1px solid black; width: 10%; margin-top: 5px; margin-left: 0;">
<p>Printing reference of object is not allow in java <br>
Command to print reference of the object will be change by compiler. <br>
String str1=new String("Avinash");  <br>
System.out.println(str1);  <br>
Since str1 is a reference of string class object and reference can not be display then compiler change this command <br>
This command will be as follows-  <br>
System.out.println(str1.tostring());  <br>
print() to display the value of return by tostring()</p>
<h4>Constructor will perform following task</h4>
<hr style="border: 1px solid black; width: 30%; margin-top: 5px; margin-left: 0;">
<p>
1➡️Create char type array <br>
2➡️Assign string to the array <br>
3➡️Keep reference of the array into object <br>
4➡️And finally reference of the object will be returned to the program    
</p>
<h4>Printing reference of the object</h4>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p>
In java reference of the object can not be displayed <br>
It is not allowed in java <br>
Compiler will change command to print reference of the object <br>
AA obj=new AA(); //obj is reference of object <br>
System.out.println(obj); <br>
Above command will be as follows in class file <br>
System.out.println(obj.toString()); //toString() is method of Object class <br>
toString() is method of Object class.So value returned by this method will be printed rather than reference of the object <br>
Remember every class in java is child/sub of Object class so every class in java has toString() method <br>
Remember toString method can be overridden by every class in java <br>
toString() method is used to display the value of object <br>
String class,StringBuffer class and StringBuilder class have already overridden this method <br>
toString() method of these classes will return value of char type array.You can say string kept into object of these classes <br>
String str1=new String("Avinash"); <br>
StringBuffer str2=new StringBuffer("Akash"); <br>
StringBuilder str3=new StringBuilder("Devansh"); <br>
System.out.println(str1); //Command generated by compiler <br>
System.out.println(str2); //Command generated by compiler <br>
System.out.println(str3); //Command generated by compiler <br>
//Command generated by compiler will be as follows <br>
System.out.println(str1.toString()); //Command generated by compiler <br>
System.out.println(str2.toString()); //Command generated by compiler <br>
System.out.println(str3.toString()); //Command generated by compiler <br>
Here value returned by toString() method will be printed  
</p>
<h4>public String toString()</h4>
<hr style="border: 1px solid black; width: 18%; margin-top: 5px; margin-left: 0;">
<p>
It is a method of object class(Remember object class is supermost class in java Every class inherits
properties from object class) <br>
It returns combination of following three values <br> 
1)Name of the class(object reference given to the method) <br>
2)@ is the separator <br>
3)Hexedecimal value of object's hashcode <br>
This method is already overridden by string class,StringBuffer class,StringBuilder class tostring() method of
these classes returns value of these classes object. <br>
It means value of char type array <br>
It means string kept into object of these classes <br>
</p>
<h1>String Class</h1>
<p>
It is an immutable class in java <br>
Immutable means non-modifiable or non-changeable <br>
So value of string class object can not be modified/change <br>
It means string kept into object of String class can not be modified/changed <br>
StringBufffer class and StringBuilder class are mutable classes <br>
JVM create object of this class automatically for each string value(such as "abc") and return reference of that object to the program <br>
JVM create this object string constant pool area in memory <br>
JVM create only one object for same value of string <br>
JVM creates this object in string pool area in memory.This area is also known as string constant pool area in memory <br>
JVM will not create new object for same value of string <br>
For same string value only one object from String class will be created by JVM    
</p>
<h4>Example</h4>
<p>
String str="abc"; <br>
1.Reference variable str will be created in stack area <br>
2.Object of string class will be created in string constant pool for the value abc and reference of
object will be return to the program <br>
3.This reference will be assinged to variable str. <br>
String str1="abc"; <br>
String str2="abc"; <br>
String str3="abc"; <br>
//JVM create only one object in same value string constant pool area <br>
//Here Single object of string class will be created  <br>
//Variable str1,str2,str3 will hold reference of that object.   
</p>
<h4>NOTE</h4>
<hr style="border: 1px solid black; width: 10%; margin-top: 5px; margin-left: 0;">
<p> 
<span class="highlight">String str1=new String("Avinash") //This is a string literal <br>
    string str2=new String("Avinash") //This is a string literal <br></span>
System.out.prtintln(str1==str2)//false <br>
System.out.prtintln(str1.equal(str2))//True  <br>
String uses both heap memory and the constant pool. In the constant pool, a string object is created, and its
reference is stored in the heap memory. The constant pool can also return this reference. <br>
For the same value, the constant pool creates only one object and returns it. That’s why, if str1 and str2 
have the same value, str1.equals(str2) will return true because both str1 and str2 refer to the same value 
(and the same object in the constant pool). <br>
However, str1 == str2 will return false because == compares the memory references.  <br>
If str1 and str2 are created in the heap memory (using new String()), <br>
they will have different references, even if the values are the same. <br>
Because in heap memory, different variables or objects have different references, and the == method compares 
references, it will return false. However, both variables store the value of the same object. <br>
In the heap memory, separate references are created for different objects, even if the values are the same.  <br>
But in both cases, the same value is stored in the objects. <br>
<span class="highlight">MyString str1 = new MyString("Avinash"); // str1 is a reference to the object created in heap memory
    MyString str2 = new MyString("Avinash"); // str2 is a reference to another object created in heap memory <br></span>
System.out.println(str1 == str2); // Output: false (different references) <br>
System.out.println(str1.equals(str2)); // Output: false <br>
If MyString is a custom class and doesn't override the equals() method or 
implement custom behavior, it will behave like a regular object in Java. Here's what happens:
Object.equals() method, which also compares references. <br>
In this case, str1.equals(str2) will also return false. <br>
<span class="highlight">String str1="Avinash" //This is a string literal <br>
String str2="Avinash" //This is a string literal <br>
</span>
System.out.prtintln(str1==str2)//True  <br>
System.out.prtintln(str1.equal(str2))//True <br>
Both str1 and str2 are stored in the String Constant Pool. <br>
str1 == str2 => True means it is checking the value in the String Constant Pool. In the String Constant Pool, for the same value, only one object
is created, so the reference is also the same. That’s why both variables have the same reference. <br>
<span class="highlight">MyString str1 = "Avinash"; // str1 is a reference to the object created in the String Constant Pool <br>
    MyString str2 = "Avinash"; // str2 is a reference to the same object created in the String Constant Pool <br></span>
System.out.prtintln(str1==str2)//false  <br>
System.out.prtintln(str1.equal(str2))//false <br>
MyString is a custom class and doesn't override the equals() method or implement custom behavior,
it will behave like a regular object in Java. Here's what happens:
</p>
<h4>StringBuffer class</h4>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p>
It is mutable class so string kipt into object of this class can be modified/change
This is syncronized class.
</p>
<h4>StringBuilder class</h4>
<hr style="border: 1px solid black; width: 25%; margin-top: 5px; margin-left: 0;">
<p>It is mutable class so string kipt into object of this class can be modified/change
This is unsyncronized class.</p>
</div>
</body>
</html>